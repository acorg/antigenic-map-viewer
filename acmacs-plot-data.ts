/// <reference path="build/jquery" />
/// <reference path="build/three" />

/// <reference path="antigenic-map-viewer.d.ts" />

// ----------------------------------------------------------------------
// Interface for plot data structure generated by acmacs
// ----------------------------------------------------------------------

export type PlotDataLayout = AntigenicMapViewer.PlotDataLayout;

// ----------------------------------------------------------------------

export class PlotData
{
    private _label_types :string[];

    constructor(private plot_data :AntigenicMapViewer.PlotDataInterface) {
    }

    public number_of_dimensions() :number {
        return this.plot_data.layout[0].length;
    }

    public styles() :AntigenicMapViewer.PlotDataStyle[] {
        return this.plot_data.styles.styles;
    }

    public style_no(index :number) :number {
        return this.plot_data.styles.points[index];
    }

    public layout() :AntigenicMapViewer.PlotDataLayout {
        return this.plot_data.layout;
    }

    public make_styles(circle_geometry :THREE.Geometry, box_geometry :THREE.Geometry, material_class :MaterialClass) :ObjectStyle[] {
        return this.styles().map((style :AntigenicMapViewer.PlotDataStyle) => new ObjectStyle(style, circle_geometry, box_geometry, material_class));
    }

    public label_types() :string[] {
        if (!this._label_types) {
            this._label_types = [];
            try {
                var kk :string[] = [];
                for (var point_no = 0; point_no < this.plot_data.point_info.length; ++point_no) {
                    for (var k in this.plot_data.point_info[point_no]) {
                        kk.push(k);
                    }
                }
                kk.sort();
                for (var k_no = 0; k_no < kk.length; ++k_no) {
                    if (k_no === 0 || kk[k_no] !== kk[k_no - 1]) {
                        this._label_types.push(kk[k_no]);
                    }
                }
            } catch (err) {
                console.error('error looking for label_types:', err);
            }
        }
        return this._label_types;
    }

    public default_label_type() :string {
        var label_type = "label_capitalized";
        var all_label_types = this.label_types();
        if (all_label_types.length !== 0 && all_label_types.indexOf(label_type) === -1) {
            label_type = all_label_types[0];
        }
        return label_type;
    }

    public label_of(index :number, label_type :string) :string {
        var labels :any = this.plot_data.point_info[index];
        var label :string = labels[label_type];
        if (label === null || label === undefined) {
            // No label_type present for this point, return any existing label_type
            for (var lt in labels) {
                label = labels[lt];
                break;
            }
            if (label === null || label === undefined) {
                // no labels for this point at all
                label = "*no label for " + index + "*";
            }
        }
        return label;
    }
}

// ----------------------------------------------------------------------

export interface ObjectUserData
{
    index :number;
}

// ----------------------------------------------------------------------

export interface MaterialClass
{
    new (parameters: THREE.MaterialParameters): THREE.Material;
}

// ----------------------------------------------------------------------

export class ObjectStyle
{
    private material :THREE.Material
    private shown :Boolean
    private size :number
    private geometry :THREE.Geometry

    constructor(plot_style :AntigenicMapViewer.PlotDataStyle, circle_geometry :THREE.Geometry, box_geometry :THREE.Geometry, material_class :MaterialClass) {
        this.material = new material_class({color: this.convert_color(plot_style.fill_color)})
        this.shown = plot_style.shown === undefined || plot_style.shown
        this.size = plot_style.size
        switch (plot_style.shape) {
        case "box":
        case "cube":
            this.geometry = box_geometry;
            break;
        case "circle":
        default:
            this.geometry = circle_geometry;
            break;
        }
    }

    public make(position :number[], user_data :ObjectUserData) :THREE.Mesh {
        var obj :THREE.Mesh = null;
        if (this.shown) {
            obj = new THREE.Mesh(this.geometry, this.material);
            obj.position.set.apply(obj.position, position);
            obj.scale.multiplyScalar(this.size)
            obj.userData = user_data;
        }
        return obj
    }

    private convert_color(source :any) :number {
        var color = new THREE.Color()
        if ($.type(source) === "string") {
            color.set(source)
        }
        else if ($.type(source) === "array") {
            color.set(source[0])
        }
        return color.getHex()
    }
}

// ----------------------------------------------------------------------
